import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type {
  AppState,
  Profile,
  StepAnswer,
  DailyCard,
  JournalEntry,
  WorksheetResponse,
  EmergencyAction,
  AppSettings,
  FellowshipContact,
  Streaks,
  StreakData,
  CelebratedMilestone,
  UnlockedAchievement,
  ChallengeCompletion,
  AnalyticsEvent,
  AnalyticsEventType,
  RecoveryPointLedger,
  RecoveryPointTransaction,
  RecoveryPointReward,
  RecoveryPointRedemption,
  RecoveryPointAwardPayload,
  RecoveryPointSummary,
  RecoveryPointSource,
  AISponsorMessage,
  AISponsorChatState,
  CopilotSettings,
  WeeklyDigest,
  Pattern,
  RecoveryScene,
  SceneAction,
  SceneUsage,
  SponsorRelationship,
  SharedItem,
  SponsorMessage,
  SponsorSummary,
  RiskSignal,
  JITAIRule,
  InterventionFeedback,
  CopingToolUsage,
  CopingToolEffectiveness,
  CopingToolRecommendation,
  SafetyPlan,
  SafetyPlanUsage,
  MeetingCache,
  MeetingSearchFilters,
  Meeting
} from '@/types';
import { storageManager } from '@/lib/storage';
import { migrateState, CURRENT_VERSION } from './migrations';
import { defaultFeatureFlags } from './featureFlags';
import {
  updateStreak,
  checkStreakBroken,
  breakStreak,
  initializeStreak
} from '@/lib/streaks';
import { createInitialRecoveryPoints } from './recoveryPointsDefaults';
import { detectRiskSignals as detectRiskSignalsEngine, type RiskDetectionContext } from '@/lib/jitai-engine';
import { personalizeSuggestions as personalizeSuggestionsLearning } from '@/lib/jitai-learning';
import {
  calculateEffectiveness,
  getRecommendations,
  buildPersonalPlaybook,
} from '@/lib/coping-coach';

const defaultEmergencyActions: EmergencyAction[] = [
  {
    id: 'call-sponsor',
    label: 'Call My Sponsor',
    type: 'call',
    data: 'tel:+61400000000',
    icon: 'phone',
  },
  {
    id: 'breathing',
    label: 'Breathing Exercise',
    type: 'exercise',
    data: 'breathing',
    icon: 'heart',
  },
  {
    id: 'timer',
    label: '5 Minute Timer',
    type: 'timer',
    data: '300',
    icon: 'clock',
  },
  {
    id: 'coping-notes',
    label: 'Coping Notes',
    type: 'notes',
    data: 'Remember: This feeling is temporary. You are strong. Call someone if needed.',
    icon: 'file-text',
  },
];

const initialStreaks: Streaks = {
  journaling: initializeStreak('journaling'),
  dailyCards: initializeStreak('dailyCards'),
  meetings: initializeStreak('meetings'),
  stepWork: initializeStreak('stepWork'),
  recoveryRhythm: initializeStreak('recoveryRhythm'),
};

const initialRecoveryPoints: RecoveryPointLedger = createInitialRecoveryPoints();

const initialState: AppState = {
  version: CURRENT_VERSION,
  profile: undefined,
  stepAnswers: {},
  dailyCards: {},
  journalEntries: {},
  worksheetResponses: {},
  meetings: [],
  emergencyActions: defaultEmergencyActions,
  fellowshipContacts: {},
  favoriteQuotes: [],
  settings: {
    theme: 'system',
    highContrast: false,
    reducedMotion: false,
    cloudSync: false,
      notifications: {
        enabled: false,
        permission: 'default',
        morningCheckIn: {
          enabled: true,
          time: '08:00'
        },
        eveningReflection: {
          enabled: true,
          time: '20:00'
        },
        middayPulseCheck: {
          enabled: false,
          time: '14:00'
        },
        milestoneAlerts: true,
        streakReminders: true,
        challengeReminders: true,
        quietHours: {
          enabled: true,
          start: '22:00',
          end: '07:00'
        },
        jitaiNotifications: {
          enabled: true,
          respectQuietHours: true,
          maxPerDay: 3
        },
        meetingReminders: {
          enabled: false,
          minutesBefore: [15, 30, 60],
          respectQuietHours: true
        }
      },
    enableVoiceRecording: false,
    analytics: {
      enabled: false,
      collectUsageData: true,
      collectPerformanceData: false,
      retentionDays: 90,
    },
  },
  onboardingComplete: false,
  streaks: initialStreaks,
  celebratedMilestones: {},
  unlockedAchievements: {},
  completedChallenges: {},
  analyticsEvents: {},
  recoveryPoints: initialRecoveryPoints,
  aiSponsorChat: {
    messages: {},
    isTyping: false,
    settings: {
      includeStepWork: true,
      includeJournals: true,
      includeScenes: true,
      includeDailyCards: true,
      autoGenerateDigest: false,
    },
  },
  recoveryScenes: {},
  sceneUsages: {},
  sponsorRelationships: {},
  sharedItems: {},
  sponsorMessages: {},
  sponsorSummaries: {},
  riskSignals: {},
  jitaiRules: {},
  interventionFeedback: {},
  copingToolUsage: {},
  copingToolEffectiveness: {},
  safetyPlanUsages: {},
  meetingSearchFilters: {},
};

interface AppStore extends AppState {
  // Profile
  setProfile: (profile: Profile) => void;
  updateProfile: (updates: Partial<Profile>) => void;
  
  // Onboarding
  completeOnboarding: () => void;
  
  // Step Answers
  saveStepAnswer: (answer: StepAnswer) => void;
  getStepAnswers: (stepNumber: number) => StepAnswer[];
  
  // Daily Cards
  getDailyCard: (date: string) => DailyCard | undefined;
  updateDailyCard: (date: string, updates: Partial<Omit<DailyCard, 'id' | 'date'>>) => void;
  
  // Recovery Rhythm actions
  setMorningIntention: (date: string, intention: DailyCard['morningIntention'], custom?: string, reminder?: string) => void;
  setMiddayPulseCheck: (date: string, mood: number, craving: number, context: string[]) => void;
  setEveningInventory: (date: string, stayedClean: DailyCard['eveningStayedClean'], stayedConnected: DailyCard['eveningStayedConnected'], gratitude?: string, improvement?: string) => void;
  
  // Journal
  addJournalEntry: (entry: Omit<JournalEntry, 'id' | 'updatedAtISO'>) => void;
  updateJournalEntry: (id: string, updates: Partial<JournalEntry>) => void;
  deleteJournalEntry: (id: string) => void;
  getJournalEntries: () => JournalEntry[];
  
  // Worksheets
  saveWorksheetResponse: (response: Omit<WorksheetResponse, 'id' | 'createdAtISO' | 'updatedAtISO'>) => void;
  updateWorksheetResponse: (id: string, responses: Record<string, any>) => void;
  getWorksheetResponses: (templateId: string) => WorksheetResponse[];
  
  // Emergency Actions
  updateEmergencyAction: (id: string, updates: Partial<EmergencyAction>) => void;
  
  // Fellowship Contacts
  addContact: (contact: Omit<FellowshipContact, 'id' | 'createdAtISO' | 'updatedAtISO'>) => void;
  updateContact: (id: string, updates: Partial<FellowshipContact>) => void;
  deleteContact: (id: string) => void;
  getContacts: () => FellowshipContact[];
  getEmergencyContacts: () => FellowshipContact[];
  
  // Favorite Quotes
  toggleFavoriteQuote: (quoteId: string) => void;
  isFavoriteQuote: (quoteId: string) => boolean;
  
  // Settings
  updateSettings: (updates: Partial<AppSettings>) => void;

  // Notifications (V2)
  updateNotificationPermission: (permission: NotificationPermission) => void;
  updateNotificationSettings: (updates: Partial<AppSettings['notifications']>) => void;
  enableNotifications: () => void;
  disableNotifications: () => void;

  // Data Management
  exportData: () => AppState;
  importData: (data: Partial<AppState>) => void;
  clearAllData: () => void;

  // Streak Management (V2)
  updateStreakForJournal: () => void;
  updateStreakForDailyCard: () => void;
  updateStreakForMeeting: () => void;
  updateStreakForStepWork: () => void;
  checkAllStreaks: () => void;
  getStreak: (type: StreakData['type']) => StreakData;

  // Milestone Celebrations (V2)
  celebrateMilestone: (milestone: CelebratedMilestone) => void;
  getCelebratedMilestones: () => Record<string, CelebratedMilestone>;

  // Achievement System (V2)
  unlockAchievement: (achievement: UnlockedAchievement) => void;
  getUnlockedAchievements: () => Record<string, UnlockedAchievement>;

  // Daily Challenges (V2)
  completeChallenge: (challengeId: string, notes?: string) => void;
  getCompletedChallenges: () => Record<string, ChallengeCompletion>;

  // Analytics (V3)
  trackAnalyticsEvent: (type: AnalyticsEventType, metadata?: Record<string, any>) => void;
  getAnalyticsEvents: () => Record<string, AnalyticsEvent>;
  clearOldAnalyticsEvents: () => void;
  updateAnalyticsSettings: (updates: Partial<AppSettings['analytics']>) => void;

  // Recovery Points (V3)
  awardPoints: (payload: RecoveryPointAwardPayload) => void;
  redeemReward: (rewardId: string, notes?: string) => void;
  exportRecoveryPointsSummary: () => RecoveryPointSummary;

  // AI Sponsor Chat (V4)
  addAISponsorMessage: (message: Omit<AISponsorMessage, 'id' | 'timestamp'>) => void;
  getAISponsorMessages: () => AISponsorMessage[];
  setAISponsorTyping: (isTyping: boolean) => void;
  clearAISponsorChat: () => void;

  // Recovery Copilot (V4)
  updateCopilotSettings: (updates: Partial<CopilotSettings>) => void;
  setWeeklyDigest: (digest: WeeklyDigest) => void;
  setDetectedPatterns: (patterns: Pattern[]) => void;
  clearWeeklyDigest: () => void;
  clearDetectedPatterns: () => void;

  // Recovery Scenes
  createRecoveryScene: (scene: Omit<RecoveryScene, 'id' | 'createdAtISO' | 'updatedAtISO' | 'usageCount'>) => string;
  updateRecoveryScene: (sceneId: string, updates: Partial<RecoveryScene>) => void;
  deleteRecoveryScene: (sceneId: string) => void;
  getRecoveryScene: (sceneId: string) => RecoveryScene | undefined;
  getAllRecoveryScenes: () => RecoveryScene[];
  getActiveRecoveryScenes: () => RecoveryScene[];
  activateScene: (sceneId: string, activationType: SceneUsage['activationType']) => string; // Returns usage ID
  completeSceneAction: (usageId: string, actionId: string) => void;
  recordSceneOutcome: (usageId: string, outcome: SceneUsage['outcome'], notes?: string) => void;
  getScenesForTime: (date: Date) => RecoveryScene[];
  getScenesForContext: (mood?: number, craving?: number, context?: string[]) => RecoveryScene[];

  // Sponsor Connection
  generateSponsorCode: () => string;
  connectToSponsor: (code: string, sponseeName?: string) => Promise<void>;
  acceptConnection: (relationshipId: string) => void;
  revokeConnection: (relationshipId: string) => void;
  getActiveRelationships: () => SponsorRelationship[];
  getRelationshipByCode: (code: string) => SponsorRelationship | undefined;
  
  // Sharing Management
  shareItem: (itemType: SharedItem['itemType'], itemId: string, relationshipId: string, version?: number) => void;
  revokeSharing: (sharedItemId: string) => void;
  getSharedItems: (relationshipId: string) => SharedItem[];
  isItemShared: (itemType: SharedItem['itemType'], itemId: string, relationshipId: string) => boolean;
  getSharedItemsForItem: (itemType: SharedItem['itemType'], itemId: string) => SharedItem[];
  markSharedItemViewed: (sharedItemId: string) => void;
  
  // Messaging
  sendSponsorMessage: (relationshipId: string, content: string) => Promise<void>;
  getMessages: (relationshipId: string) => SponsorMessage[];
  markMessageRead: (messageId: string) => void;
  
  // Summaries
  generateWeeklySummary: (relationshipId: string) => Promise<SponsorSummary>;
  sendSummaryToSponsor: (summaryId: string, relationshipId: string) => void;

  // JITAI (Just-in-Time Adaptive Intervention)
  // Risk Detection
  detectRiskSignals: () => RiskSignal[]; // Analyze current state, return new signals
  dismissRiskSignal: (signalId: string) => void;
  actOnRiskSignal: (signalId: string, actionId: string) => void;
  recordInterventionFeedback: (signalId: string, helpful: boolean, notes?: string) => void;

  // Rule Management
  createJITAIRule: (rule: Omit<JITAIRule, 'id' | 'createdAtISO' | 'triggerCount'>) => string;
  updateJITAIRule: (ruleId: string, updates: Partial<JITAIRule>) => void;
  deleteJITAIRule: (ruleId: string) => void;
  getActiveJITAIRules: () => JITAIRule[];

  // Learning
  updateRuleEffectiveness: (ruleId: string) => void; // Recalculate based on feedback
  getPersonalizedSuggestions: (context: { mood?: number; craving?: number; scene?: string }) => string[]; // Get suggestions for context

  // Coping Coach - Tool Usage Tracking
  recordToolUsage: (toolName: string, context: CopingToolUsage['context']) => string; // Returns usage ID
  recordToolOutcome: (usageId: string, outcome: CopingToolUsage['outcome']) => void;
  getToolUsage: (toolName: string) => CopingToolUsage[];
  getRecentToolUsage: (limit?: number) => CopingToolUsage[];
  
  // Coping Coach - Effectiveness Calculation
  calculateToolEffectiveness: (toolName: string) => CopingToolEffectiveness;
  updateAllEffectiveness: () => void; // Recalculate all tools
  
  // Coping Coach - Recommendations
  getRecommendedTools: (context: { mood?: number; craving?: number; sceneId?: string }) => CopingToolRecommendation[];
  getPersonalPlaybook: () => Record<string, string>; // "When X, try Y" format
  
  // Safety Plan CRUD
  createSafetyPlan: (plan: Omit<SafetyPlan, 'id' | 'version' | 'createdAtISO' | 'updatedAtISO' | 'usageCount'>) => void;
  updateSafetyPlan: (updates: Partial<SafetyPlan>) => void;
  getSafetyPlan: () => SafetyPlan | undefined;
  deleteSafetyPlan: () => void;
  
  // Safety Plan Usage
  activateSafetyPlan: (activationType: SafetyPlanUsage['activationType']) => string; // Returns usage ID
  completeSafetyPlanAction: (actionId: string) => void;
  contactSafetyPlanPerson: (contactId: string) => void;
  recordSafetyPlanOutcome: (usageId: string, outcome: SafetyPlanUsage['outcome'], notes?: string) => void;
  
  // Meeting Finder
  setBMLTConfig: (apiRoot: string, apiKey?: string) => void;
  setMeetingCache: (cache: MeetingCache) => void;
  getCachedMeetings: () => Meeting[] | null;
  addFavoriteMeeting: (meetingId: string) => void;
  removeFavoriteMeeting: (meetingId: string) => void;
  isFavoriteMeeting: (meetingId: string) => boolean;
  setMeetingReminder: (meetingId: string, enabled: boolean, minutesBefore: number) => void;
  getFavoriteMeetings: () => Meeting[];
  getMeetingsWithReminders: () => Meeting[];
  updateMeetingSearchFilters: (filters: Partial<MeetingSearchFilters>) => void;
}

export const useAppStore = create<AppStore>()(
  persist(
    (set, get) => ({
      ...initialState,
      
      // Profile
      setProfile: (profile) => set({ profile }),
      
      updateProfile: (updates) => set((state) => {
        if (!state.profile) {
          const newProfile = {
            id: `user_${Date.now()}`,
            name: 'User',
            cleanDate: new Date().toISOString(),
            timezone: 'Australia/Melbourne',
            hasPasscode: false,
            ...updates,
          };
          return { profile: newProfile };
        }
        return { profile: { ...state.profile, ...updates } };
      }),
      
      // Onboarding
      completeOnboarding: () => set({ onboardingComplete: true }),
      
      // Step Answers
      saveStepAnswer: (answer) => {
        const now = new Date().toISOString();
        set((state) => ({
          stepAnswers: {
            ...state.stepAnswers,
            [answer.questionId]: answer,
          },
          streaks: {
            ...state.streaks,
            stepWork: updateStreak(state.streaks.stepWork, now)
          }
        }));
      },
      
      getStepAnswers: (stepNumber) => {
        const state = get();
        return Object.values(state.stepAnswers).filter(
          (answer) => answer.stepNumber === stepNumber
        );
      },
      
      // Daily Cards
      getDailyCard: (date) => get().dailyCards[date],
      
      updateDailyCard: (date, updates) => {
        const now = new Date().toISOString();
        set((state) => {
          const existing = state.dailyCards[date];
          const card: DailyCard = existing
            ? { ...existing, ...updates, updatedAtISO: now }
            : {
                id: date,
                date,
                morningCompleted: false,
                eveningCompleted: false,
                middayCompleted: false,
                ...updates,
                updatedAtISO: now,
              };

          // Update streak if morning or evening is being completed
          const shouldUpdateStreak =
            (updates.morningCompleted && !existing?.morningCompleted) ||
            (updates.eveningCompleted && !existing?.eveningCompleted);

          return {
            dailyCards: {
              ...state.dailyCards,
              [date]: card,
            },
            streaks: shouldUpdateStreak ? {
              ...state.streaks,
              dailyCards: updateStreak(state.streaks.dailyCards, now)
            } : state.streaks
          };
        });
      },
      
      // Recovery Rhythm actions
      setMorningIntention: (date, intention, custom, reminder) => {
        const now = new Date().toISOString();
        set((state) => {
          const existing = state.dailyCards[date];
          const card: DailyCard = existing
            ? {
                ...existing,
                morningIntention: intention,
                morningIntentionCustom: custom,
                morningReminder: reminder,
                morningCompleted: true,
                updatedAtISO: now,
              }
            : {
                id: date,
                date,
                morningIntention: intention,
                morningIntentionCustom: custom,
                morningReminder: reminder,
                morningCompleted: true,
                eveningCompleted: false,
                middayCompleted: false,
                updatedAtISO: now,
              };

          // Check if all 3 check-ins are complete for recovery rhythm streak
          const allComplete = card.morningCompleted && card.middayCompleted && card.eveningCompleted;
          const wasAllComplete = existing?.morningCompleted && existing?.middayCompleted && existing?.eveningCompleted;
          const shouldUpdateRhythmStreak = allComplete && !wasAllComplete;

          return {
            dailyCards: {
              ...state.dailyCards,
              [date]: card,
            },
            streaks: shouldUpdateRhythmStreak ? {
              ...state.streaks,
              recoveryRhythm: updateStreak(state.streaks.recoveryRhythm, now)
            } : state.streaks
          };
        });
        
        get().trackAnalyticsEvent('morning_intention_set', {
          intention,
          hasCustom: !!custom,
          hasReminder: !!reminder,
        });
      },
      
      setMiddayPulseCheck: (date, mood, craving, context) => {
        const now = new Date().toISOString();
        set((state) => {
          const existing = state.dailyCards[date];
          const card: DailyCard = existing
            ? {
                ...existing,
                middayPulseCheck: {
                  mood,
                  craving,
                  context,
                  timestampISO: now,
                },
                middayCompleted: true,
                updatedAtISO: now,
              }
            : {
                id: date,
                date,
                middayPulseCheck: {
                  mood,
                  craving,
                  context,
                  timestampISO: now,
                },
                morningCompleted: false,
                eveningCompleted: false,
                middayCompleted: true,
                updatedAtISO: now,
              };

          // Check if all 3 check-ins are complete for recovery rhythm streak
          const allComplete = card.morningCompleted && card.middayCompleted && card.eveningCompleted;
          const wasAllComplete = existing?.morningCompleted && existing?.middayCompleted && existing?.eveningCompleted;
          const shouldUpdateRhythmStreak = allComplete && !wasAllComplete;

          return {
            dailyCards: {
              ...state.dailyCards,
              [date]: card,
            },
            streaks: shouldUpdateRhythmStreak ? {
              ...state.streaks,
              recoveryRhythm: updateStreak(state.streaks.recoveryRhythm, now)
            } : state.streaks
          };
        });
        
        get().trackAnalyticsEvent('midday_pulse_check_completed', {
          mood,
          craving,
          contextCount: context.length,
        });
      },
      
      setEveningInventory: (date, stayedClean, stayedConnected, gratitude, improvement) => {
        const now = new Date().toISOString();
        set((state) => {
          const existing = state.dailyCards[date];
          const card: DailyCard = existing
            ? {
                ...existing,
                eveningStayedClean: stayedClean,
                eveningStayedConnected: stayedConnected,
                eveningGratitude: gratitude,
                eveningImprovement: improvement,
                eveningCompleted: true,
                updatedAtISO: now,
              }
            : {
                id: date,
                date,
                eveningStayedClean: stayedClean,
                eveningStayedConnected: stayedConnected,
                eveningGratitude: gratitude,
                eveningImprovement: improvement,
                morningCompleted: false,
                eveningCompleted: true,
                middayCompleted: false,
                updatedAtISO: now,
              };

          // Check if all 3 check-ins are complete for recovery rhythm streak
          const allComplete = card.morningCompleted && card.middayCompleted && card.eveningCompleted;
          const wasAllComplete = existing?.morningCompleted && existing?.middayCompleted && existing?.eveningCompleted;
          const shouldUpdateRhythmStreak = allComplete && !wasAllComplete;

          return {
            dailyCards: {
              ...state.dailyCards,
              [date]: card,
            },
            streaks: shouldUpdateRhythmStreak ? {
              ...state.streaks,
              recoveryRhythm: updateStreak(state.streaks.recoveryRhythm, now)
            } : state.streaks
          };
        });
        
        get().trackAnalyticsEvent('evening_inventory_completed', {
          stayedClean,
          hasGratitude: !!gratitude,
          hasImprovement: !!improvement,
        });
      },
      
      // Journal
      addJournalEntry: (entry) => {
        const id = `journal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const now = new Date().toISOString();
        const newEntry: JournalEntry = {
          ...entry,
          id,
          updatedAtISO: now,
        };

        set((state) => ({
          journalEntries: {
            ...state.journalEntries,
            [id]: newEntry,
          },
          streaks: {
            ...state.streaks,
            journaling: updateStreak(state.streaks.journaling, now)
          }
        }));
      },
      
      updateJournalEntry: (id, updates) => set((state) => {
        const existing = state.journalEntries[id];
        if (!existing) return state;
        
        return {
          journalEntries: {
            ...state.journalEntries,
            [id]: {
              ...existing,
              ...updates,
              updatedAtISO: new Date().toISOString(),
            },
          },
        };
      }),
      
      deleteJournalEntry: (id) => set((state) => {
        const { [id]: _, ...rest } = state.journalEntries;
        return { journalEntries: rest };
      }),
      
      getJournalEntries: () => {
        const state = get();
        return Object.values(state.journalEntries).sort(
          (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
        );
      },
      
      // Worksheets
      saveWorksheetResponse: (response) => set((state) => {
        const id = `worksheet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const now = new Date().toISOString();
        const newResponse: WorksheetResponse = {
          ...response,
          id,
          createdAtISO: now,
          updatedAtISO: now,
        };
        
        return {
          worksheetResponses: {
            ...state.worksheetResponses,
            [id]: newResponse,
          },
        };
      }),
      
      updateWorksheetResponse: (id, responses) => set((state) => {
        const existing = state.worksheetResponses[id];
        if (!existing) return state;
        
        return {
          worksheetResponses: {
            ...state.worksheetResponses,
            [id]: {
              ...existing,
              responses,
              updatedAtISO: new Date().toISOString(),
            },
          },
        };
      }),
      
      getWorksheetResponses: (templateId) => {
        const state = get();
        return Object.values(state.worksheetResponses)
          .filter((r) => r.templateId === templateId)
          .sort((a, b) => new Date(b.createdAtISO).getTime() - new Date(a.createdAtISO).getTime());
      },
      
      // Emergency Actions
      updateEmergencyAction: (id, updates) => set((state) => ({
        emergencyActions: state.emergencyActions.map((action) =>
          action.id === id ? { ...action, ...updates } : action
        ),
      })),
      
      // Fellowship Contacts
      addContact: (contact) => set((state) => {
        const id = `contact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const now = new Date().toISOString();
        const newContact: FellowshipContact = {
          ...contact,
          id,
          createdAtISO: now,
          updatedAtISO: now,
        };
        
        return {
          fellowshipContacts: {
            ...state.fellowshipContacts,
            [id]: newContact,
          },
        };
      }),
      
      updateContact: (id, updates) => set((state) => {
        const existing = state.fellowshipContacts[id];
        if (!existing) return state;
        
        return {
          fellowshipContacts: {
            ...state.fellowshipContacts,
            [id]: {
              ...existing,
              ...updates,
              updatedAtISO: new Date().toISOString(),
            },
          },
        };
      }),
      
      deleteContact: (id) => set((state) => {
        const { [id]: _, ...rest } = state.fellowshipContacts;
        return { fellowshipContacts: rest };
      }),
      
      getContacts: () => {
        const state = get();
        return Object.values(state.fellowshipContacts).sort(
          (a, b) => new Date(b.createdAtISO).getTime() - new Date(a.createdAtISO).getTime()
        );
      },
      
      getEmergencyContacts: () => {
        const state = get();
        return Object.values(state.fellowshipContacts)
          .filter((contact) => contact.isEmergencyContact)
          .sort((a, b) => new Date(b.createdAtISO).getTime() - new Date(a.createdAtISO).getTime());
      },
      
      // Favorite Quotes
      toggleFavoriteQuote: (quoteId) => set((state) => {
        const isFavorite = state.favoriteQuotes.includes(quoteId);
        return {
          favoriteQuotes: isFavorite
            ? state.favoriteQuotes.filter((id) => id !== quoteId)
            : [...state.favoriteQuotes, quoteId],
        };
      }),
      
      isFavoriteQuote: (quoteId) => {
        return get().favoriteQuotes.includes(quoteId);
      },
      
      // Settings
      updateSettings: (updates) => set((state) => ({
        settings: { ...state.settings, ...updates },
      })),

      // Notifications (V2)
      updateNotificationPermission: (permission) => set((state) => ({
        settings: {
          ...state.settings,
          notifications: {
            ...state.settings.notifications,
            permission
          }
        }
      })),

      updateNotificationSettings: (updates) => set((state) => ({
        settings: {
          ...state.settings,
          notifications: {
            ...state.settings.notifications,
            ...updates
          }
        }
      })),

      enableNotifications: () => set((state) => ({
        settings: {
          ...state.settings,
          notifications: {
            ...state.settings.notifications,
            enabled: true
          }
        }
      })),

      disableNotifications: () => set((state) => ({
        settings: {
          ...state.settings,
          notifications: {
            ...state.settings.notifications,
            enabled: false
          }
        }
      })),

      // Data Management
      exportData: () => get(),
      
      importData: (data) => set((state) => {
        // Merge imported data with existing, preferring newest based on updatedAtISO
        const mergeByTimestamp = <T extends { updatedAtISO?: string }>(
          existing: Record<string, T>,
          imported: Record<string, T>
        ): Record<string, T> => {
          const merged = { ...existing };

          Object.entries(imported).forEach(([key, value]) => {
            const existingItem = merged[key];
            if (!existingItem ||
                (value.updatedAtISO && existingItem.updatedAtISO &&
                 new Date(value.updatedAtISO) > new Date(existingItem.updatedAtISO))) {
              merged[key] = value;
            }
          });

          return merged;
        };

        const mergeRecoveryLedger = (
          existing: RecoveryPointLedger,
          incoming?: RecoveryPointLedger | null
        ): RecoveryPointLedger => {
          if (!incoming) return existing;

          const mergedTransactions: Record<string, RecoveryPointTransaction> = {
            ...existing.transactions,
            ...incoming.transactions,
          };

          const mergedRewards: Record<string, RecoveryPointReward> = {
            ...existing.rewards,
            ...incoming.rewards,
          };

          const mergedRedemptions: Record<string, RecoveryPointRedemption> = {
            ...existing.redemptions,
            ...incoming.redemptions,
          };

          const balance: RecoveryPointLedger['balance'] = {
            current:
              typeof incoming.balance?.current === 'number'
                ? incoming.balance.current
                : existing.balance.current,
            lifetimeEarned: Math.max(
              existing.balance.lifetimeEarned,
              incoming.balance?.lifetimeEarned ?? 0
            ),
            lifetimeRedeemed: Math.max(
              existing.balance.lifetimeRedeemed,
              incoming.balance?.lifetimeRedeemed ?? 0
            ),
          };

          return {
            balance,
            transactions: mergedTransactions,
            rewards: mergedRewards,
            redemptions: mergedRedemptions,
          };
        };

        return {
          ...state,
          profile: data.profile || state.profile,
          stepAnswers: data.stepAnswers ? mergeByTimestamp(state.stepAnswers, data.stepAnswers) : state.stepAnswers,
          dailyCards: data.dailyCards ? mergeByTimestamp(state.dailyCards, data.dailyCards) : state.dailyCards,
          journalEntries: data.journalEntries ? mergeByTimestamp(state.journalEntries, data.journalEntries) : state.journalEntries,
          worksheetResponses: data.worksheetResponses ? mergeByTimestamp(state.worksheetResponses, data.worksheetResponses) : state.worksheetResponses,
          fellowshipContacts: data.fellowshipContacts ? mergeByTimestamp(state.fellowshipContacts, data.fellowshipContacts) : state.fellowshipContacts,
          favoriteQuotes: data.favoriteQuotes || state.favoriteQuotes,
          settings: data.settings || state.settings,
          recoveryPoints: data.recoveryPoints
            ? mergeRecoveryLedger(state.recoveryPoints, data.recoveryPoints)
            : state.recoveryPoints,
          sponsorRelationships: data.sponsorRelationships ? mergeByTimestamp(state.sponsorRelationships || {}, data.sponsorRelationships) : state.sponsorRelationships,
          sharedItems: data.sharedItems ? mergeByTimestamp(state.sharedItems || {}, data.sharedItems) : state.sharedItems,
          sponsorMessages: data.sponsorMessages ? mergeByTimestamp(state.sponsorMessages || {}, data.sponsorMessages) : state.sponsorMessages,
          sponsorSummaries: data.sponsorSummaries ? mergeByTimestamp(state.sponsorSummaries || {}, data.sponsorSummaries) : state.sponsorSummaries,
        };
      }),

      clearAllData: () => set(initialState),

      // Streak Management (V2)
      updateStreakForJournal: () => set((state) => {
        const now = new Date().toISOString();
        return {
          streaks: {
            ...state.streaks,
            journaling: updateStreak(state.streaks.journaling, now)
          }
        };
      }),

      updateStreakForDailyCard: () => set((state) => {
        const now = new Date().toISOString();
        return {
          streaks: {
            ...state.streaks,
            dailyCards: updateStreak(state.streaks.dailyCards, now)
          }
        };
      }),

      updateStreakForMeeting: () => set((state) => {
        const now = new Date().toISOString();
        return {
          streaks: {
            ...state.streaks,
            meetings: updateStreak(state.streaks.meetings, now)
          }
        };
      }),

      updateStreakForStepWork: () => set((state) => {
        const now = new Date().toISOString();
        return {
          streaks: {
            ...state.streaks,
            stepWork: updateStreak(state.streaks.stepWork, now)
          }
        };
      }),

      checkAllStreaks: () => set((state) => {
        const newStreaks = { ...state.streaks };
        let hasChanges = false;

        // Initialize recoveryRhythm if missing
        if (!newStreaks.recoveryRhythm) {
          newStreaks.recoveryRhythm = initializeStreak('recoveryRhythm');
          hasChanges = true;
        }

        (Object.keys(newStreaks) as Array<keyof Streaks>).forEach((key) => {
          if (checkStreakBroken(newStreaks[key])) {
            newStreaks[key] = breakStreak(newStreaks[key]);
            hasChanges = true;
          }
        });

        return hasChanges ? { streaks: newStreaks } : state;
      }),

      getStreak: (type) => {
        return get().streaks[type];
      },

      // Milestone Celebrations (V2)
      celebrateMilestone: (milestone) => set((state) => ({
        celebratedMilestones: {
          ...state.celebratedMilestones,
          [milestone.id]: milestone
        }
      })),

      getCelebratedMilestones: () => {
        return get().celebratedMilestones || {};
      },

      // Achievement System (V2)
      unlockAchievement: (achievement) => set((state) => ({
        unlockedAchievements: {
          ...state.unlockedAchievements,
          [achievement.achievementId]: achievement
        }
      })),

      getUnlockedAchievements: () => {
        return get().unlockedAchievements || {};
      },

      // Daily Challenges (V2)
      completeChallenge: (challengeId, notes) => set((state) => {
        const id = `challenge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const completion: ChallengeCompletion = {
          id,
          challengeId,
          completedAtISO: new Date().toISOString(),
          notes,
        };

        return {
          completedChallenges: {
            ...state.completedChallenges,
            [id]: completion,
          },
        };
      }),

      getCompletedChallenges: () => {
        return get().completedChallenges || {};
      },

      // Recovery Points (V3)
      awardPoints: (payload) => {
        if (!payload || payload.amount <= 0) {
          return;
        }

        const transactionId = `points_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const timestamp = new Date().toISOString();

        const transaction: RecoveryPointTransaction = {
          id: transactionId,
          type: 'award',
          amount: payload.amount,
          reason: payload.reason,
          source: payload.source,
          relatedId: payload.relatedId,
          timestamp,
          metadata: payload.metadata,
        };

        set((state) => ({
          recoveryPoints: {
            ...state.recoveryPoints,
            balance: {
              current: state.recoveryPoints.balance.current + payload.amount,
              lifetimeEarned: state.recoveryPoints.balance.lifetimeEarned + payload.amount,
              lifetimeRedeemed: state.recoveryPoints.balance.lifetimeRedeemed,
            },
            transactions: {
              ...state.recoveryPoints.transactions,
              [transactionId]: transaction,
            },
          },
        }));

        get().trackAnalyticsEvent('recovery_points_awarded', {
          amount: payload.amount,
          source: payload.source,
          reason: payload.reason,
          relatedId: payload.relatedId,
          ...payload.metadata,
        });
      },

      redeemReward: (rewardId, notes) => {
        const state = get();
        const reward = state.recoveryPoints.rewards[rewardId];
        if (!reward || !reward.available) {
          return;
        }

        if (state.recoveryPoints.balance.current < reward.cost) {
          return;
        }

        const timestamp = new Date().toISOString();
        const transactionId = `points_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const redemptionId = `redemption_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        const transaction: RecoveryPointTransaction = {
          id: transactionId,
          type: 'redeem',
          amount: reward.cost,
          reason: `Redeemed ${reward.name}`,
          source: 'redemption',
          relatedId: rewardId,
          timestamp,
          metadata: notes ? { notes } : undefined,
        };

        const redemption: RecoveryPointRedemption = {
          id: redemptionId,
          rewardId,
          redeemedAtISO: timestamp,
          notes,
          transactionId,
        };

        set((state) => ({
          recoveryPoints: {
            ...state.recoveryPoints,
            balance: {
              current: state.recoveryPoints.balance.current - reward.cost,
              lifetimeEarned: state.recoveryPoints.balance.lifetimeEarned,
              lifetimeRedeemed: state.recoveryPoints.balance.lifetimeRedeemed + reward.cost,
            },
            transactions: {
              ...state.recoveryPoints.transactions,
              [transactionId]: transaction,
            },
            redemptions: {
              ...state.recoveryPoints.redemptions,
              [redemptionId]: redemption,
            },
          },
        }));

        get().trackAnalyticsEvent('recovery_reward_redeemed', {
          rewardId,
          cost: reward.cost,
          notes,
        });
      },

      exportRecoveryPointsSummary: () => {
        const state = get();
        const transactions = Object.values(state.recoveryPoints.transactions || {});

        const awardsBySource: Partial<Record<RecoveryPointSource, number>> = {};
        let lastAwardedAt: string | undefined;
        let lastRedeemedAt: string | undefined;

        transactions.forEach((transaction) => {
          if (transaction.type === 'award') {
            awardsBySource[transaction.source] =
              (awardsBySource[transaction.source] || 0) + transaction.amount;
            if (!lastAwardedAt || transaction.timestamp > lastAwardedAt) {
              lastAwardedAt = transaction.timestamp;
            }
          } else if (transaction.type === 'redeem') {
            if (!lastRedeemedAt || transaction.timestamp > lastRedeemedAt) {
              lastRedeemedAt = transaction.timestamp;
            }
          }
        });

        const summary: RecoveryPointSummary = {
          currentBalance: state.recoveryPoints.balance.current,
          lifetimeEarned: state.recoveryPoints.balance.lifetimeEarned,
          lifetimeRedeemed: state.recoveryPoints.balance.lifetimeRedeemed,
          transactionCount: transactions.length,
          awardsBySource: awardsBySource as RecoveryPointSummary['awardsBySource'],
          lastAwardedAt,
          lastRedeemedAt,
        };

        get().trackAnalyticsEvent('recovery_points_summary_exported', {
          transactionCount: summary.transactionCount,
          currentBalance: summary.currentBalance,
          lifetimeEarned: summary.lifetimeEarned,
          lifetimeRedeemed: summary.lifetimeRedeemed,
        });

        return summary;
      },

      // Analytics (V3)
      trackAnalyticsEvent: (type, metadata) => {
        const state = get();
        if (!state.settings.analytics.enabled) {
          return;
        }

        const id = `analytics_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const event: AnalyticsEvent = {
          id,
          type,
          timestamp: new Date().toISOString(),
          metadata,
        };

        set((state) => ({
          analyticsEvents: {
            ...state.analyticsEvents,
            [id]: event,
          },
        }));
      },

      getAnalyticsEvents: () => {
        return get().analyticsEvents || {};
      },

      clearOldAnalyticsEvents: () => set((state) => {
        const retentionDays = state.settings.analytics.retentionDays;
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
        const cutoffTimestamp = cutoffDate.toISOString();

        const cleaned: Record<string, AnalyticsEvent> = {};
        for (const [id, event] of Object.entries(state.analyticsEvents || {})) {
          if (event.timestamp >= cutoffTimestamp) {
            cleaned[id] = event;
          }
        }

        return { analyticsEvents: cleaned };
      }),

      updateAnalyticsSettings: (updates) => set((state) => ({
        settings: {
          ...state.settings,
          analytics: {
            ...state.settings.analytics,
            ...updates,
          },
        },
      })),

      // AI Sponsor Chat (V4)
      addAISponsorMessage: (message) => {
        const id = `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        const timestamp = new Date().toISOString();

        set((state) => {
          const currentChat = state.aiSponsorChat || {
            messages: {},
            isTyping: false,
            settings: {
              includeStepWork: true,
              includeJournals: true,
              includeScenes: true,
              includeDailyCards: true,
              autoGenerateDigest: false,
            },
          };

          return {
            aiSponsorChat: {
              ...currentChat,
              messages: {
                ...currentChat.messages,
                [id]: {
                  id,
                  timestamp,
                  ...message,
                },
              },
              isTyping: currentChat.isTyping || false,
              lastMessageTimestamp: timestamp,
            },
          };
        });

        // Track analytics if enabled
        try {
          const currentState = get();
          if (currentState.settings?.analytics?.enabled) {
            const eventType: AnalyticsEventType =
              message.role === 'user'
                ? 'ai_sponsor_message_sent'
                : 'ai_sponsor_message_received';
            currentState.trackAnalyticsEvent(eventType, { messageLength: message.content?.length || 0 });
          }
        } catch (error) {
          console.error('Error tracking analytics event:', error);
        }
      },

      getAISponsorMessages: () => {
        try {
          const currentChat = get().aiSponsorChat;
          const messages = currentChat?.messages || {};
          return Object.values(messages).sort(
            (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
        } catch (error) {
          console.error('Error getting AI sponsor messages:', error);
          return [];
        }
      },

      setAISponsorTyping: (isTyping) => set((state) => {
        const currentChat = state.aiSponsorChat || {
          messages: {},
          isTyping: false,
          settings: {
            includeStepWork: true,
            includeJournals: true,
            includeScenes: true,
            includeDailyCards: true,
            autoGenerateDigest: false,
          },
        };

        return {
          aiSponsorChat: {
            ...currentChat,
            messages: currentChat.messages || {},
            isTyping: Boolean(isTyping),
          },
        };
      }),

      clearAISponsorChat: () => set({
        aiSponsorChat: {
          messages: {},
          isTyping: false,
          settings: get().aiSponsorChat?.settings || {
            includeStepWork: true,
            includeJournals: true,
            includeScenes: true,
            includeDailyCards: true,
            autoGenerateDigest: false,
          },
        },
      }),

      // Recovery Copilot (V4)
      updateCopilotSettings: (updates) => set((state) => {
        const currentChat = state.aiSponsorChat || {
          messages: {},
          isTyping: false,
          settings: {
            includeStepWork: true,
            includeJournals: true,
            includeScenes: true,
            includeDailyCards: true,
            autoGenerateDigest: false,
          },
        };

        return {
          aiSponsorChat: {
            ...currentChat,
            messages: currentChat.messages || {},
            isTyping: currentChat.isTyping || false,
            settings: {
              ...currentChat.settings,
              ...updates,
            } as CopilotSettings,
          },
        };
      }),

      setWeeklyDigest: (digest) => set((state) => {
        const currentChat = state.aiSponsorChat || {
          messages: {},
          isTyping: false,
          settings: {
            includeStepWork: true,
            includeJournals: true,
            includeScenes: true,
            includeDailyCards: true,
            autoGenerateDigest: false,
          },
        };

        return {
          aiSponsorChat: {
            ...currentChat,
            messages: currentChat.messages || {},
            isTyping: currentChat.isTyping || false,
            settings: currentChat.settings || {
              includeStepWork: true,
              includeJournals: true,
              includeScenes: true,
              includeDailyCards: true,
              autoGenerateDigest: false,
            },
            weeklyDigest: digest,
          },
        };
      }),

      setDetectedPatterns: (patterns) => set((state) => {
        const currentChat = state.aiSponsorChat || {
          messages: {},
          isTyping: false,
          settings: {
            includeStepWork: true,
            includeJournals: true,
            includeScenes: true,
            includeDailyCards: true,
            autoGenerateDigest: false,
          },
        };

        return {
          aiSponsorChat: {
            ...currentChat,
            messages: currentChat.messages || {},
            isTyping: currentChat.isTyping || false,
            settings: currentChat.settings || {
              includeStepWork: true,
              includeJournals: true,
              includeScenes: true,
              includeDailyCards: true,
              autoGenerateDigest: false,
            },
            detectedPatterns: Array.isArray(patterns) ? patterns : [],
          },
        };
      }),

      clearWeeklyDigest: () => set((state) => {
        const currentChat = state.aiSponsorChat || {
          messages: {},
          isTyping: false,
          settings: {
            includeStepWork: true,
            includeJournals: true,
            includeScenes: true,
            includeDailyCards: true,
            autoGenerateDigest: false,
          },
        };

        return {
          aiSponsorChat: {
            ...currentChat,
            messages: currentChat.messages || {},
            isTyping: currentChat.isTyping || false,
            settings: currentChat.settings || {
              includeStepWork: true,
              includeJournals: true,
              includeScenes: true,
              includeDailyCards: true,
              autoGenerateDigest: false,
            },
            weeklyDigest: undefined,
          },
        };
      }),

      clearDetectedPatterns: () => set((state) => {
        const currentChat = state.aiSponsorChat || {
          messages: {},
          isTyping: false,
          settings: {
            includeStepWork: true,
            includeJournals: true,
            includeScenes: true,
            includeDailyCards: true,
            autoGenerateDigest: false,
          },
        };

        return {
          aiSponsorChat: {
            ...currentChat,
            messages: currentChat.messages || {},
            isTyping: currentChat.isTyping || false,
            settings: currentChat.settings || {
              includeStepWork: true,
              includeJournals: true,
              includeScenes: true,
              includeDailyCards: true,
              autoGenerateDigest: false,
            },
            detectedPatterns: undefined,
          },
        };
      }),

      // Recovery Scenes
      createRecoveryScene: (scene) => {
        const id = `scene_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        const now = new Date().toISOString();
        const newScene: RecoveryScene = {
          ...scene,
          id,
          createdAtISO: now,
          updatedAtISO: now,
          usageCount: 0,
        };

        set((state) => ({
          recoveryScenes: {
            ...(state.recoveryScenes || {}),
            [id]: newScene,
          },
        }));

        return id;
      },

      updateRecoveryScene: (sceneId, updates) => set((state) => {
        const existing = state.recoveryScenes?.[sceneId];
        if (!existing) return state;

        return {
          recoveryScenes: {
            ...(state.recoveryScenes || {}),
            [sceneId]: {
              ...existing,
              ...updates,
              updatedAtISO: new Date().toISOString(),
            },
          },
        };
      }),

      deleteRecoveryScene: (sceneId) => set((state) => {
        const scenes = state.recoveryScenes || {};
        const { [sceneId]: _, ...rest } = scenes;
        return { recoveryScenes: rest };
      }),

      getRecoveryScene: (sceneId) => {
        return get().recoveryScenes?.[sceneId];
      },

      getAllRecoveryScenes: () => {
        const scenes = get().recoveryScenes || {};
        return Object.values(scenes).sort(
          (a, b) => new Date(b.updatedAtISO).getTime() - new Date(a.updatedAtISO).getTime()
        );
      },

      getActiveRecoveryScenes: () => {
        const scenes = get().recoveryScenes || {};
        return Object.values(scenes)
          .filter((scene) => scene.active)
          .sort(
            (a, b) => new Date(b.updatedAtISO).getTime() - new Date(a.updatedAtISO).getTime()
          );
      },

      activateScene: (sceneId, activationType) => {
        const scene = get().recoveryScenes?.[sceneId];
        if (!scene) throw new Error(`Scene ${sceneId} not found`);

        const usageId = `usage_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        const now = new Date().toISOString();

        const usage: SceneUsage = {
          id: usageId,
          sceneId,
          activatedAtISO: now,
          activationType,
          actionsCompleted: [],
        };

        // Update scene usage count and last used
        set((state) => ({
          recoveryScenes: {
            ...(state.recoveryScenes || {}),
            [sceneId]: {
              ...scene,
              usageCount: scene.usageCount + 1,
              lastUsedISO: now,
              updatedAtISO: now,
            },
          },
          sceneUsages: {
            ...(state.sceneUsages || {}),
            [usageId]: usage,
          },
        }));

        return usageId;
      },

      completeSceneAction: (usageId, actionId) => set((state) => {
        const usage = state.sceneUsages?.[usageId];
        if (!usage) return state;

        const actionsCompleted = usage.actionsCompleted.includes(actionId)
          ? usage.actionsCompleted
          : [...usage.actionsCompleted, actionId];

        return {
          sceneUsages: {
            ...(state.sceneUsages || {}),
            [usageId]: {
              ...usage,
              actionsCompleted,
            },
          },
        };
      }),

      recordSceneOutcome: (usageId, outcome, notes) => set((state) => {
        const usage = state.sceneUsages?.[usageId];
        if (!usage) return state;

        return {
          sceneUsages: {
            ...(state.sceneUsages || {}),
            [usageId]: {
              ...usage,
              outcome,
              notes,
            },
          },
        };
      }),

      getScenesForTime: (date) => {
        const scenes = get().getActiveRecoveryScenes();
        const dayOfWeek = date.getDay();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const currentTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

        return scenes.filter((scene) => {
          if (!scene.timeTriggers) return false;

          const { dayOfWeek: triggerDays, timeRange } = scene.timeTriggers;

          // Check day of week
          if (triggerDays && !triggerDays.includes(dayOfWeek)) {
            return false;
          }

          // Check time range
          if (timeRange) {
            const { start, end } = timeRange;
            if (currentTime < start || currentTime > end) {
              return false;
            }
          }

          return true;
        });
      },

      getScenesForContext: (mood, craving, context) => {
        // Simple matching: scenes with triggers that match context keywords
        const scenes = get().getActiveRecoveryScenes();
        if (!context || context.length === 0) return [];

        const contextLower = context.map((c) => c.toLowerCase());

        return scenes.filter((scene) => {
          const sceneTriggersLower = scene.triggers.map((t) => t.toLowerCase());
          return sceneTriggersLower.some((trigger) =>
            contextLower.some((ctx) => ctx.includes(trigger) || trigger.includes(ctx))
          );
        });
      },

      // Sponsor Connection
      generateSponsorCode: () => {
        // Generate a unique 6-digit code
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        const now = new Date().toISOString();
        const profile = get().profile;
        const userId = profile?.id || `user_${Date.now()}`;
        
        const relationship: SponsorRelationship = {
          id: `relationship_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
          sponsorId: userId,
          sponsorCode: code,
          role: 'sponsor',
          status: 'pending',
          createdAtISO: now,
          sponsorName: profile?.name,
          sponsorPhone: profile?.sponsorPhone,
        };

        set((state) => ({
          sponsorRelationships: {
            ...(state.sponsorRelationships || {}),
            [relationship.id]: relationship,
          },
        }));

        return code;
      },

      connectToSponsor: async (code: string, sponseeName?: string) => {
        const state = get();
        const relationships = state.sponsorRelationships || {};
        
        // Find relationship by code
        const relationship = Object.values(relationships).find(
          (rel) => rel.sponsorCode === code && rel.status === 'pending'
        );

        if (!relationship) {
          throw new Error('Invalid sponsor code. Please check and try again.');
        }

        const profile = state.profile;
        const sponseeId = profile?.id || `user_${Date.now()}`;
        const now = new Date().toISOString();

        // Create sponsee-side relationship
        const sponseeRelationship: SponsorRelationship = {
          id: `relationship_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
          sponsorId: relationship.sponsorId,
          sponsorCode: code,
          sponseeId,
          role: 'sponsee',
          status: 'pending',
          createdAtISO: now,
          sponsorName: relationship.sponsorName,
          sponsorPhone: relationship.sponsorPhone,
        };

        // Update sponsor-side relationship with sponsee info
        const updatedSponsorRelationship: SponsorRelationship = {
          ...relationship,
          sponseeId,
          sponseeName: sponseeName || profile?.name,
        };

        set((state) => ({
          sponsorRelationships: {
            ...(state.sponsorRelationships || {}),
            [relationship.id]: updatedSponsorRelationship,
            [sponseeRelationship.id]: sponseeRelationship,
          },
        }));
      },

      acceptConnection: (relationshipId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const relationships = state.sponsorRelationships || {};
          const relationship = relationships[relationshipId];
          if (!relationship) return state;

          // Update both sponsor and sponsee relationships
          const updated: Record<string, SponsorRelationship> = {};
          
          Object.values(relationships).forEach((rel) => {
            if (
              rel.sponsorCode === relationship.sponsorCode &&
              (rel.id === relationshipId || rel.sponsorId === relationship.sponsorId)
            ) {
              updated[rel.id] = {
                ...rel,
                status: 'active',
                acceptedAtISO: now,
              };
            } else {
              updated[rel.id] = rel;
            }
          });

          return { sponsorRelationships: updated };
        });
      },

      revokeConnection: (relationshipId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const relationships = state.sponsorRelationships || {};
          const relationship = relationships[relationshipId];
          if (!relationship) return state;

          const updated: Record<string, SponsorRelationship> = {};
          
          // Revoke all relationships with this code
          Object.values(relationships).forEach((rel) => {
            if (rel.sponsorCode === relationship.sponsorCode) {
              updated[rel.id] = {
                ...rel,
                status: 'revoked',
                revokedAtISO: now,
              };
            } else {
              updated[rel.id] = rel;
            }
          });

          return { sponsorRelationships: updated };
        });
      },

      getActiveRelationships: () => {
        const relationships = get().sponsorRelationships || {};
        return Object.values(relationships).filter(
          (rel) => rel.status === 'active'
        );
      },

      getRelationshipByCode: (code: string) => {
        const relationships = get().sponsorRelationships || {};
        return Object.values(relationships).find(
          (rel) => rel.sponsorCode === code
        );
      },

      // Sharing Management
      shareItem: (itemType, itemId, relationshipId, version) => {
        const now = new Date().toISOString();
        const sharedItem: SharedItem = {
          id: `shared_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
          itemType,
          itemId,
          relationshipId,
          sharedAtISO: now,
          version,
        };

        set((state) => ({
          sharedItems: {
            ...(state.sharedItems || {}),
            [sharedItem.id]: sharedItem,
          },
        }));
      },

      revokeSharing: (sharedItemId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const sharedItems = state.sharedItems || {};
          const item = sharedItems[sharedItemId];
          if (!item) return state;

          return {
            sharedItems: {
              ...sharedItems,
              [sharedItemId]: {
                ...item,
                revokedAtISO: now,
              },
            },
          };
        });
      },

      getSharedItems: (relationshipId: string) => {
        const sharedItems = get().sharedItems || {};
        return Object.values(sharedItems).filter(
          (item) => item.relationshipId === relationshipId && !item.revokedAtISO
        );
      },

      isItemShared: (itemType, itemId, relationshipId) => {
        const sharedItems = get().sharedItems || {};
        return Object.values(sharedItems).some(
          (item) =>
            item.itemType === itemType &&
            item.itemId === itemId &&
            item.relationshipId === relationshipId &&
            !item.revokedAtISO
        );
      },

      getSharedItemsForItem: (itemType, itemId) => {
        const sharedItems = get().sharedItems || {};
        return Object.values(sharedItems).filter(
          (item) => item.itemType === itemType && item.itemId === itemId && !item.revokedAtISO
        );
      },

      markSharedItemViewed: (sharedItemId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const sharedItems = state.sharedItems || {};
          const item = sharedItems[sharedItemId];
          if (!item) return state;

          return {
            sharedItems: {
              ...sharedItems,
              [sharedItemId]: {
                ...item,
                lastViewedAtISO: now,
              },
            },
          };
        });
      },

      // Messaging
      sendSponsorMessage: async (relationshipId: string, content: string, nonce?: string) => {
        // Content should already be encrypted when passed in
        // Nonce should be provided if encryption was done externally
        const now = new Date().toISOString();
        const state = get();
        const profile = state.profile;
        const userId = profile?.id || `user_${Date.now()}`;
        const relationship = state.sponsorRelationships?.[relationshipId];
        
        if (!relationship) {
          throw new Error('Relationship not found');
        }

        const threadId = relationshipId; // Use relationshipId as threadId
        const recipientId = relationship.role === 'sponsor' 
          ? relationship.sponseeId || ''
          : relationship.sponsorId;

        const message: SponsorMessage = {
          id: `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
          threadId,
          relationshipId,
          senderId: userId,
          recipientId,
          contentCiphertext: content,
          nonce: nonce || '',
          createdAtISO: now,
        };

        set((state) => ({
          sponsorMessages: {
            ...(state.sponsorMessages || {}),
            [message.id]: message,
          },
        }));
      },

      getMessages: (relationshipId: string) => {
        const messages = get().sponsorMessages || {};
        return Object.values(messages)
          .filter((msg) => msg.relationshipId === relationshipId)
          .sort((a, b) => new Date(a.createdAtISO).getTime() - new Date(b.createdAtISO).getTime());
      },

      markMessageRead: (messageId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const messages = state.sponsorMessages || {};
          const message = messages[messageId];
          if (!message) return state;

          return {
            sponsorMessages: {
              ...messages,
              [messageId]: {
                ...message,
                readAtISO: now,
              },
            },
          };
        });
      },

      // Summaries
      generateWeeklySummary: async (relationshipId: string) => {
        // Generate a simple summary (can be enhanced with AI later)
        const now = new Date().toISOString();
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - 7);
        
        const sharedItems = get().getSharedItems(relationshipId);
        const summary: SponsorSummary = {
          id: `summary_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
          relationshipId,
          periodStartISO: startDate.toISOString(),
          periodEndISO: now,
          summary: `Weekly summary: ${sharedItems.length} items shared this week.`,
          sharedAtISO: now,
        };

        set((state) => ({
          sponsorSummaries: {
            ...(state.sponsorSummaries || {}),
            [summary.id]: summary,
          },
        }));

        return summary;
      },

      sendSummaryToSponsor: (summaryId: string, relationshipId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const summaries = state.sponsorSummaries || {};
          const summary = summaries[summaryId];
          if (!summary) return state;

          return {
            sponsorSummaries: {
              ...summaries,
              [summaryId]: {
                ...summary,
                sharedAtISO: now,
              },
            },
          };
        });
      },

      // JITAI (Just-in-Time Adaptive Intervention)
      // Risk Detection
      detectRiskSignals: () => {
        const state = get();
        const context: RiskDetectionContext = {
          dailyCards: state.dailyCards || {},
          journalEntries: state.journalEntries || {},
          meetings: state.meetings || [],
          recoveryScenes: state.recoveryScenes || {},
          sceneUsages: state.sceneUsages || {},
          jitaiRules: state.jitaiRules || {},
        };

        const newSignals = detectRiskSignalsEngine(context);
        
        // Add new signals to state (only if they don't already exist)
        // Also update rule trigger counts
        if (newSignals.length > 0) {
          const existingSignals = state.riskSignals || {};
          const signalsToAdd: Record<string, RiskSignal> = {};
          const rulesToUpdate: Record<string, Partial<JITAIRule>> = {};
          const now = new Date().toISOString();
          
          for (const signal of newSignals) {
            // Only add if not already dismissed and not duplicate
            const isDuplicate = Object.values(existingSignals).some(
              (existing) =>
                existing.type === signal.type &&
                existing.detectedAtISO === signal.detectedAtISO &&
                !existing.dismissedAtISO
            );
            
            if (!isDuplicate) {
              signalsToAdd[signal.id] = signal;
              
              // Update rule trigger count if this is from a custom rule
              if (signal.type === 'custom' && signal.inputs.ruleId) {
                const ruleId = signal.inputs.ruleId as string;
                const rule = state.jitaiRules?.[ruleId];
                if (rule) {
                  rulesToUpdate[ruleId] = {
                    triggerCount: rule.triggerCount + 1,
                    lastTriggeredAtISO: now,
                  };
                }
              }
            }
          }

          if (Object.keys(signalsToAdd).length > 0 || Object.keys(rulesToUpdate).length > 0) {
            set((state) => {
              const updatedRules = { ...(state.jitaiRules || {}) };
              for (const [ruleId, updates] of Object.entries(rulesToUpdate)) {
                updatedRules[ruleId] = { ...updatedRules[ruleId], ...updates };
              }
              
              return {
                riskSignals: {
                  ...(state.riskSignals || {}),
                  ...signalsToAdd,
                },
                jitaiRules: updatedRules,
              };
            });
          }
        }

        // Return only active (non-dismissed) signals
        const allSignals = { ...(state.riskSignals || {}), ...newSignals.reduce((acc, s) => ({ ...acc, [s.id]: s }), {}) };
        return Object.values(allSignals).filter((s) => !s.dismissedAtISO);
      },

      dismissRiskSignal: (signalId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const signals = state.riskSignals || {};
          const signal = signals[signalId];
          if (!signal) return state;

          return {
            riskSignals: {
              ...signals,
              [signalId]: {
                ...signal,
                dismissedAtISO: now,
              },
            },
          };
        });
      },

      actOnRiskSignal: (signalId: string, actionId: string) => {
        const now = new Date().toISOString();
        set((state) => {
          const signals = state.riskSignals || {};
          const signal = signals[signalId];
          if (!signal) return state;

          return {
            riskSignals: {
              ...signals,
              [signalId]: {
                ...signal,
                actedUponAtISO: now,
              },
            },
          };
        });
      },

      recordInterventionFeedback: (signalId: string, helpful: boolean, notes?: string) => {
        const state = get();
        const signals = state.riskSignals || {};
        const signal = signals[signalId];
        if (!signal) return;

        const now = new Date().toISOString();
        const feedbackId = `feedback_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

        const feedback: InterventionFeedback = {
          id: feedbackId,
          signalId,
          ruleId: signal.inputs.ruleId || '',
          interventionType: signal.type,
          helpful,
          notes,
          timestampISO: now,
        };

        // Update signal outcome
        const outcome: RiskSignal['outcome'] = helpful ? 'helped' : 'didnt-help';
        
        set((state) => ({
          interventionFeedback: {
            ...(state.interventionFeedback || {}),
            [feedbackId]: feedback,
          },
          riskSignals: {
            ...(state.riskSignals || {}),
            [signalId]: {
              ...signal,
              outcome,
            },
          },
        }));

        // Update rule effectiveness if ruleId exists
        if (signal.inputs.ruleId) {
          get().updateRuleEffectiveness(signal.inputs.ruleId);
        }
      },

      // Rule Management
      createJITAIRule: (rule: Omit<JITAIRule, 'id' | 'createdAtISO' | 'triggerCount'>) => {
        const id = `rule_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        const now = new Date().toISOString();
        const newRule: JITAIRule = {
          ...rule,
          id,
          createdAtISO: now,
          triggerCount: 0,
        };

        set((state) => ({
          jitaiRules: {
            ...(state.jitaiRules || {}),
            [id]: newRule,
          },
        }));

        return id;
      },

      updateJITAIRule: (ruleId: string, updates: Partial<JITAIRule>) => {
        set((state) => {
          const rules = state.jitaiRules || {};
          const rule = rules[ruleId];
          if (!rule) return state;

          return {
            jitaiRules: {
              ...rules,
              [ruleId]: {
                ...rule,
                ...updates,
              },
            },
          };
        });
      },

      deleteJITAIRule: (ruleId: string) => {
        set((state) => {
          const rules = state.jitaiRules || {};
          const { [ruleId]: _, ...rest } = rules;
          return { jitaiRules: rest };
        });
      },

      getActiveJITAIRules: () => {
        const rules = get().jitaiRules || {};
        return Object.values(rules).filter((rule) => rule.enabled);
      },

      // Learning
      updateRuleEffectiveness: (ruleId: string) => {
        const state = get();
        const feedback = state.interventionFeedback || {};
        const rule = state.jitaiRules?.[ruleId];
        if (!rule) return;

        // Get all feedback for this rule
        const ruleFeedback = Object.values(feedback).filter(
          (f) => f.ruleId === ruleId
        );

        if (ruleFeedback.length === 0) {
          return;
        }

        // Calculate effectiveness score (0-100)
        const helpfulCount = ruleFeedback.filter((f) => f.helpful).length;
        const effectivenessScore = Math.round((helpfulCount / ruleFeedback.length) * 100);

        set((state) => {
          const rules = state.jitaiRules || {};
          return {
            jitaiRules: {
              ...rules,
              [ruleId]: {
                ...rule,
                effectivenessScore,
              },
            },
          };
        });
      },

      getPersonalizedSuggestions: (context: { mood?: number; craving?: number; scene?: string }) => {
        const state = get();
        const rules = Object.values(state.jitaiRules || {});
        const feedback = Object.values(state.interventionFeedback || {});
        
        return personalizeSuggestionsLearning(context, rules, feedback);
      },

      // Coping Coach Actions
      recordToolUsage: (toolName, context) => {
        const id = `tool_usage_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
        const usage: CopingToolUsage = {
          id,
          toolName,
          usedAtISO: new Date().toISOString(),
          context,
        };
        
        set((state) => ({
          copingToolUsage: {
            ...(state.copingToolUsage || {}),
            [id]: usage,
          },
        }));
        
        // Track analytics event
        get().trackAnalyticsEvent('tool_used', { toolName, hasContext: !!context });
        
        return id;
      },

      recordToolOutcome: (usageId, outcome) => {
        // Validate outcome has required result field
        if (!outcome || !outcome.result) {
          console.warn('recordToolOutcome: outcome.result is required');
          return;
        }
        
        let toolName: string | undefined;
        
        set((state) => {
          const usage = state.copingToolUsage?.[usageId];
          if (!usage) return state;
          
          toolName = usage.toolName;
          
          // Ensure outcome has required fields
          const completeOutcome: CopingToolUsage['outcome'] = {
            checkedAtISO: outcome.checkedAtISO || new Date().toISOString(),
            result: outcome.result,
            notes: outcome.notes,
            cravingChange: outcome.cravingChange,
            moodChange: outcome.moodChange,
          };
          
          return {
            copingToolUsage: {
              ...state.copingToolUsage,
              [usageId]: {
                ...usage,
                outcome: completeOutcome,
              },
            },
          };
        });
        
        // Recalculate effectiveness for this tool if we found it
        if (toolName) {
          const effectiveness = get().calculateToolEffectiveness(toolName);
          set((state) => ({
            copingToolEffectiveness: {
              ...(state.copingToolEffectiveness || {}),
              [toolName!]: effectiveness,
            },
          }));
          
          // Track analytics event
          get().trackAnalyticsEvent('tool_outcome_recorded', { toolName, outcome: outcome.result });
        }
      },

      getToolUsage: (toolName) => {
        const state = get();
        return Object.values(state.copingToolUsage || {})
          .filter((usage) => usage.toolName === toolName)
          .sort((a, b) => new Date(b.usedAtISO).getTime() - new Date(a.usedAtISO).getTime());
      },

      getRecentToolUsage: (limit = 10) => {
        const state = get();
        return Object.values(state.copingToolUsage || {})
          .sort((a, b) => new Date(b.usedAtISO).getTime() - new Date(a.usedAtISO).getTime())
          .slice(0, limit);
      },

      calculateToolEffectiveness: (toolName) => {
        // Implementation will be in coping-coach.ts, called from here
        const usages = get().getToolUsage(toolName);
        return calculateEffectiveness(usages);
      },

      updateAllEffectiveness: () => {
        // Recalculate effectiveness for all tools
        const state = get();
        const toolNames = new Set(
          Object.values(state.copingToolUsage || {}).map((u) => u.toolName)
        );
        
        const effectiveness: Record<string, CopingToolEffectiveness> = {};
        toolNames.forEach((toolName) => {
          effectiveness[toolName] = get().calculateToolEffectiveness(toolName);
        });
        
        set({ copingToolEffectiveness: effectiveness });
      },

      getRecommendedTools: (context) => {
        const state = get();
        return getRecommendations(context, state.copingToolEffectiveness || {});
      },

      getPersonalPlaybook: () => {
        const state = get();
        return buildPersonalPlaybook(state.copingToolEffectiveness || {});
      },

      // Safety Plan CRUD
      createSafetyPlan: (plan) => {
        const now = new Date().toISOString();
        const newPlan: SafetyPlan = {
          ...plan,
          id: `safety-plan-${Date.now()}`,
          version: 1,
          createdAtISO: now,
          updatedAtISO: now,
          usageCount: 0,
          active: true,
        };
        set({ safetyPlan: newPlan });
      },

      updateSafetyPlan: (updates) => {
        const state = get();
        const currentPlan = state.safetyPlan;
        if (!currentPlan) return;
        
        const updatedPlan: SafetyPlan = {
          ...currentPlan,
          ...updates,
          version: currentPlan.version + 1,
          updatedAtISO: new Date().toISOString(),
        };
        set({ safetyPlan: updatedPlan });
      },

      getSafetyPlan: () => {
        return get().safetyPlan;
      },

      deleteSafetyPlan: () => {
        set({ safetyPlan: undefined });
      },

      // Safety Plan Usage
      activateSafetyPlan: (activationType) => {
        const state = get();
        const plan = state.safetyPlan;
        if (!plan) {
          throw new Error('No safety plan exists');
        }

        const now = new Date().toISOString();
        const usageId = `safety-plan-usage-${Date.now()}`;
        const usage: SafetyPlanUsage = {
          id: usageId,
          planId: plan.id,
          activatedAtISO: now,
          activationType,
          actionsCompleted: [],
        };

        const usages = state.safetyPlanUsages || {};
        set({
          safetyPlanUsages: {
            ...usages,
            [usageId]: usage,
          },
          safetyPlan: {
            ...plan,
            lastUsedISO: now,
            usageCount: plan.usageCount + 1,
          },
        });

        return usageId;
      },

      completeSafetyPlanAction: (actionId) => {
        const state = get();
        const usages = state.safetyPlanUsages || {};
        const activeUsage = Object.values(usages).find(
          (u) => !u.outcome && u.activatedAtISO > new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
        );
        
        if (!activeUsage) return;

        const updatedUsage: SafetyPlanUsage = {
          ...activeUsage,
          actionsCompleted: [...new Set([...activeUsage.actionsCompleted, actionId])],
        };

        set({
          safetyPlanUsages: {
            ...usages,
            [activeUsage.id]: updatedUsage,
          },
        });
      },

      contactSafetyPlanPerson: (contactId) => {
        const state = get();
        const usages = state.safetyPlanUsages || {};
        const activeUsage = Object.values(usages).find(
          (u) => !u.outcome && u.activatedAtISO > new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
        );
        
        if (!activeUsage) return;

        const updatedUsage: SafetyPlanUsage = {
          ...activeUsage,
          contactedPerson: contactId,
        };

        set({
          safetyPlanUsages: {
            ...usages,
            [activeUsage.id]: updatedUsage,
          },
        });
      },

      recordSafetyPlanOutcome: (usageId, outcome, notes) => {
        const state = get();
        const usages = state.safetyPlanUsages || {};
        const usage = usages[usageId];
        
        if (!usage) return;

        const updatedUsage: SafetyPlanUsage = {
          ...usage,
          outcome,
          notes,
        };

        set({
          safetyPlanUsages: {
            ...usages,
            [usageId]: updatedUsage,
          },
        });
      },

      // Meeting Finder
      setBMLTConfig: (apiRoot, apiKey) => {
        set({
          bmltApiRoot: apiRoot,
          bmltApiKey: apiKey,
        });
      },

      setMeetingCache: (cache) => {
        set({ meetingCache: cache });
      },

      getCachedMeetings: () => {
        const state = get();
        const cache = state.meetingCache;
        if (!cache) return null;
        
        const now = new Date();
        const expiresAt = new Date(cache.expiresAtISO);
        if (now >= expiresAt) {
          return null; // Cache expired
        }
        
        return cache.meetings;
      },

      addFavoriteMeeting: (meetingId) => {
        set((state) => {
          const meetings = state.meetings || [];
          const updatedMeetings = meetings.map(meeting => {
            if (meeting.id === meetingId) {
              return { ...meeting, isFavorite: true };
            }
            return meeting;
          });
          
          // Also update cache if meeting exists there
          const cache = state.meetingCache;
          if (cache) {
            const updatedCacheMeetings = cache.meetings.map(meeting => {
              if (meeting.id === meetingId) {
                return { ...meeting, isFavorite: true };
              }
              return meeting;
            });
            return {
              meetings: updatedMeetings,
              meetingCache: { ...cache, meetings: updatedCacheMeetings },
            };
          }
          
          return { meetings: updatedMeetings };
        });
      },

      removeFavoriteMeeting: (meetingId) => {
        set((state) => {
          const meetings = state.meetings || [];
          const updatedMeetings = meetings.map(meeting => {
            if (meeting.id === meetingId) {
              return { ...meeting, isFavorite: false };
            }
            return meeting;
          });
          
          // Also update cache if meeting exists there
          const cache = state.meetingCache;
          if (cache) {
            const updatedCacheMeetings = cache.meetings.map(meeting => {
              if (meeting.id === meetingId) {
                return { ...meeting, isFavorite: false };
              }
              return meeting;
            });
            return {
              meetings: updatedMeetings,
              meetingCache: { ...cache, meetings: updatedCacheMeetings },
            };
          }
          
          return { meetings: updatedMeetings };
        });
      },

      isFavoriteMeeting: (meetingId) => {
        const state = get();
        const meetings = state.meetings || [];
        
        // Check in meetings array first
        const meeting = meetings.find(m => m.id === meetingId);
        if (meeting) {
          return meeting.isFavorite || false;
        }
        
        // Also check in cache if not found in meetings array
        const cache = state.meetingCache;
        if (cache) {
          const cachedMeeting = cache.meetings.find(m => m.id === meetingId);
          if (cachedMeeting) {
            return cachedMeeting.isFavorite || false;
          }
        }
        
        return false;
      },

      setMeetingReminder: (meetingId, enabled, minutesBefore) => {
        set((state) => {
          const meetings = state.meetings || [];
          const updatedMeetings = meetings.map(meeting => {
            if (meeting.id === meetingId) {
              return {
                ...meeting,
                reminderEnabled: enabled,
                reminderMinutesBefore: minutesBefore,
              };
            }
            return meeting;
          });
          
          // Also update cache if meeting exists there
          const cache = state.meetingCache;
          if (cache) {
            const updatedCacheMeetings = cache.meetings.map(meeting => {
              if (meeting.id === meetingId) {
                return {
                  ...meeting,
                  reminderEnabled: enabled,
                  reminderMinutesBefore: minutesBefore,
                };
              }
              return meeting;
            });
            return {
              meetings: updatedMeetings,
              meetingCache: { ...cache, meetings: updatedCacheMeetings },
            };
          }
          
          return { meetings: updatedMeetings };
        });
      },

      getFavoriteMeetings: () => {
        const state = get();
        const meetings = state.meetings || [];
        const cache = state.meetingCache;
        
        // Use Set for O(1) lookup instead of O(n) find()
        const meetingIds = new Set(meetings.map(m => m.id));
        const allMeetings = [...meetings];
        
        if (cache) {
          cache.meetings.forEach(cachedMeeting => {
            if (!meetingIds.has(cachedMeeting.id)) {
              meetingIds.add(cachedMeeting.id);
              allMeetings.push(cachedMeeting);
            }
          });
        }
        
        return allMeetings.filter(m => m.isFavorite);
      },

      getMeetingsWithReminders: () => {
        const state = get();
        const meetings = state.meetings || [];
        const cache = state.meetingCache;
        
        // Use Set for O(1) lookup instead of O(n) find()
        const meetingIds = new Set(meetings.map(m => m.id));
        const allMeetings = [...meetings];
        
        if (cache) {
          cache.meetings.forEach(cachedMeeting => {
            if (!meetingIds.has(cachedMeeting.id)) {
              meetingIds.add(cachedMeeting.id);
              allMeetings.push(cachedMeeting);
            }
          });
        }
        
        return allMeetings.filter(m => m.reminderEnabled);
      },

      updateMeetingSearchFilters: (filters) => {
        set((state) => ({
          meetingSearchFilters: {
            ...state.meetingSearchFilters,
            ...filters,
          },
        }));
      },
    }),
    {
      name: 'recovery-companion-storage',
      version: CURRENT_VERSION,
      migrate: (persistedState: Partial<AppState> & { version?: number }, version: number) => {
        return migrateState(persistedState);
      },
      storage: {
        getItem: async (name) => {
          const str = await storageManager.getItem(name);
          return str ? JSON.parse(str) : null;
        },
        setItem: async (name, value) => {
          await storageManager.setItem(name, JSON.stringify(value));
        },
        removeItem: async (name) => {
          await storageManager.removeItem(name);
        },
      },
    }
  )
);
