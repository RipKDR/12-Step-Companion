/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';

declare const self: ServiceWorkerGlobalScope;

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Take control of all pages immediately
self.skipWaiting();
clientsClaim();

// Store for scheduled notification timers
const scheduledTimers = new Map<string, number>();

// Listen for messages from client
self.addEventListener('message', (event) => {
  if (event.data.type === 'SCHEDULE_NOTIFICATIONS') {
    scheduleAllNotifications(event.data.settings);
  }

  if (event.data.type === 'CLEAR_NOTIFICATIONS') {
    clearAllScheduledNotifications();
  }
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const notificationType = event.notification.data?.type;
  const action = event.action;

  // Handle different notification types
  let url = '/';

  switch (notificationType) {
    case 'morning-checkin':
      url = action === 'open' ? '/?modal=daily-intention' : '/';
      break;

    case 'evening-reflection':
      url = action === 'quick-journal' ? '/?modal=quick-journal' : '/';
      break;

    case 'milestone':
      url = '/?modal=celebration';
      break;

    case 'streak-reminder':
      url = '/?modal=quick-journal';
      break;

    case 'availability-checkin':
      url = action === 'open-contacts' ? '/contacts?focus=warmline' : '/contacts';
      break;

    default:
      url = '/';
  }

  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clients) => {
      // Check if there's already a window open
      for (const client of clients) {
        if ('focus' in client) {
          return client.focus().then(() => {
            // Navigate to the URL
            if (client.url !== url) {
              return client.navigate(url);
            }
          });
        }
      }
      // No window open, open a new one
      return self.clients.openWindow(url);
    })
  );
});

/**
 * Schedule all notifications based on settings
 */
function scheduleAllNotifications(settings: any) {
  // Clear existing timers
  clearAllScheduledNotifications();

  if (!settings.enabled) return;

  // Morning check-in
  if (settings.morningCheckIn.enabled) {
    scheduleDailyNotification(
      'morning-checkin',
      settings.morningCheckIn.time,
      {
        title: 'Good morning! ‚òÄÔ∏è',
        body: 'Set your intention for today',
        actions: [
          { action: 'open', title: 'Open App' },
          { action: 'dismiss', title: 'Dismiss' }
        ]
      },
      settings.quietHours
    );
  }

  // Evening reflection
  if (settings.eveningReflection.enabled) {
    scheduleDailyNotification(
      'evening-reflection',
      settings.eveningReflection.time,
      {
        title: 'How was your day? üåô',
        body: 'Take a moment to reflect',
        actions: [
          { action: 'quick-journal', title: 'Quick Journal' },
          { action: 'dismiss', title: 'Dismiss' }
        ]
      },
      settings.quietHours
    );
  }

  // Warmline availability check-ins
  if (settings.availabilityCheckIn && settings.availabilityCheckIn.enabled) {
    scheduleDailyNotification(
      'availability-checkin',
      settings.availabilityCheckIn.time,
      {
        title: 'Warmline availability check',
        body: settings.availabilityCheckIn.message || 'Take a moment to confirm your warmline status for today.',
        actions: [
          { action: 'open-contacts', title: 'Update Status' },
          { action: 'dismiss', title: 'Dismiss' }
        ]
      },
      settings.quietHours
    );
  }
}

/**
 * Schedule a daily recurring notification
 */
function scheduleDailyNotification(
  type: string,
  time: string,
  notification: any,
  quietHours: any
) {
  const now = new Date();
  const [hours, minutes] = time.split(':').map(Number);

  const targetTime = new Date();
  targetTime.setHours(hours, minutes, 0, 0);

  // If the time has passed today, schedule for tomorrow
  if (targetTime <= now) {
    targetTime.setDate(targetTime.getDate() + 1);
  }

  const delay = targetTime.getTime() - now.getTime();

  const timerId = self.setTimeout(() => {
    // Check if within quiet hours
    if (!isQuietHours(quietHours)) {
      self.registration.showNotification(notification.title, {
        body: notification.body,
        icon: '/favicon.png',
        badge: '/favicon.png',
        tag: type,
        data: { type },
        actions: notification.actions,
        vibrate: [200, 100, 200],
        requireInteraction: false
      });
    }

    // Reschedule for next day
    scheduledTimers.delete(type);
    scheduleDailyNotification(type, time, notification, quietHours);
  }, delay);

  scheduledTimers.set(type, timerId);
}

/**
 * Clear all scheduled notification timers
 */
function clearAllScheduledNotifications() {
  scheduledTimers.forEach((timerId) => {
    self.clearTimeout(timerId);
  });
  scheduledTimers.clear();
}

/**
 * Check if current time is within quiet hours
 */
function isQuietHours(quietHours: any): boolean {
  if (!quietHours.enabled) return false;

  const now = new Date();
  const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
  const { start, end } = quietHours;

  // Handle overnight quiet hours (e.g., 22:00 - 07:00)
  if (start > end) {
    return currentTime >= start || currentTime <= end;
  }

  return currentTime >= start && currentTime <= end;
}
